<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-10-12 Tue 15:32 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D言語におけるライフタイム</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Shigeki Karita" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/css/org.css"/>
 <link href="/css/code.css" rel="stylesheet">
 <script async src="https://www.googletagmanager.com/gtag/js?id=UA-123741131-1"></script>
 <script>window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-123741131-1'); </script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">D言語におけるライフタイム</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org258738a">1. ライフタイムと基本操作 (Programming in D翻訳)</a>
<ul>
<li><a href="#org5b61cf1">1.1. 変数のライフタイム</a></li>
<li><a href="#org51d26fe">1.2. 仮引数のライフタイム</a></li>
<li><a href="#orgf25d435">1.3. 基本操作</a>
<ul>
<li><a href="#org60926a0">1.3.1. 初期化</a></li>
<li><a href="#org1ccb967">1.3.2. ファイナライズ</a></li>
<li><a href="#org236476b">1.3.3. 代入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7e6a1d6">2. 最近のライフタイム機能</a>
<ul>
<li><a href="#orga570cee">2.1. escaping reference</a></li>
<li><a href="#orgb84bbab">2.2. return ref 仮引数</a></li>
<li><a href="#orgcee46fe">2.3. <code>@safe</code> と <code>-dip25</code> を使う</a></li>
</ul>
</li>
<li><a href="#orgaf1449c">3. DIP1000: Scoped Pointers</a>
<ul>
<li><a href="#orgeb0e6e0">3.1. 背景</a>
<ul>
<li><a href="#orge542101">3.1.1. DIP25: Sealed References (2.067で実装)</a></li>
<li><a href="#org459cccb">3.1.2. DIP35: Sealed References Amendment (ドラフト)</a></li>
<li><a href="#org9033037">3.1.3. DIP36: Rvalue References (否決)</a></li>
<li><a href="#org2baea2a">3.1.4. DIP69: Implement scope for escape proof references (-&gt; DIP90 -&gt; DIP1000)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
D言語は基本型と構造体はスタックに確保できたり，値セマンティクスだったりで，参照を扱うと何かとハマることがあります．そんなとき，日本語の解説記事があれば役に立つかもと思い筆をとりました．本稿の1章はD言語の基礎が学べる名著「Programming in D」から「ライフタイムと基本操作」の章を和訳させてもらいました．残りの2-3章ではD言語のとりあえずONにすると便利な機能(-dip25 -dip1000)を紹介します．
</p>

<div id="outline-container-org258738a" class="outline-2">
<h2 id="org258738a"><span class="section-number-2">1.</span> ライフタイムと基本操作 (Programming in D翻訳)</h2>
<div class="outline-text-2" id="text-1">
<p>
原作: "Programming in D: Lifetimes and Fundamental Operations," <a href="http://ddili.org/ders/d.en/lifetimes.html">http://ddili.org/ders/d.en/lifetimes.html</a>
</p>

<blockquote>
<p>
本章はAli Çehreli氏の著作物を<a href="http://ddili.org/copyright.html">コピーレフトライセンス</a>(<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.ja">CC BY-NC-SA3.0</a>)に基づいて翻案しています．本翻案のライセンスも継承元のライセンスに従いCC BY-NC-SA3.0とします．This page is built upon Ali Çehreli's material. This page is also distributed under CC BY-NC-SA3.0 as same as the base material.
</p>
</blockquote>

<p>
(訳注：冒頭は原作の章構成の話なので本稿にはあまり関係ないです)
</p>

<p>
我々はこの後すぐ構造体 <code>struct</code> を学びます．構造体とはアプリケーションのため独自にプログラマが定義できる型です．構造体は基本型や他の構造体を組み合わせて，プログラムに必要な特化した高レベルな型を定義するために使います．構造体の後は，クラス <code>class</code> について学びます，クラスとはD言語におけるオブジェクト指向プログラミングの基礎となる機能です．
</p>

<p>
構造体やクラスに入る前に，いくつかの重要な概念について先に話しましょう．その概念とは構造体やクラス，およびそれらの違いを理解するのに役立つものです．
</p>

<p>
我々はあらゆるデータを「変数」と呼ぶプログラム上の概念として表現します．幾つかの箇所で，我々は構造体やクラスの変数を「オブジェクト」とも呼びました．この章では，どちらの概念も「変数」と呼ぶことにします．この章では基本型，スライス，および連想配列しか扱いませんが，その概念はユーザ定義型にも同様にあてはまります．
</p>
</div>

<div id="outline-container-org5b61cf1" class="outline-3">
<h3 id="org5b61cf1"><span class="section-number-3">1.1.</span> 変数のライフタイム</h3>
<div class="outline-text-3" id="text-1-1">
<p>
変数の <i>ライフタイム</i> とは，変数が定義されてから <i>ファイナライズ</i> されるまでの期間です．多くのケースで， <i>無効</i> になるタイミングと <i>ファイナライズ</i> されるタイミングは必ずしも同時ではありません．
</p>

<p>
変数がどのように無効になるかは，<a href="http://ddili.org/ders/d.en/name_space.html">名前スコープの章</a>(訳注:未翻訳)から思い出してください．簡単なケースとして，変数が定義されたスコープを抜けるときにその変数は無効になります．
</p>

<p>
確認のために，以下の例を考えてみましょう．
</p>

<div class="org-src-container">
<pre class="src src-d"><span class="org-type">void</span> <span class="org-function-name">speedTest</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">speed</span>;               <span class="org-comment-delimiter">// </span><span class="org-comment">&#22793;&#25968;&#12398;&#23450;&#32681;</span>

    <span class="org-keyword">foreach</span> (<span class="org-variable-name">i</span>; 0 .. 10) {
        speed = 100 + i;     <span class="org-comment-delimiter">// </span><span class="org-comment">... 10&#22238;&#12398;&#30064;&#12394;&#12427;&#20516;&#12434;&#12392;&#12427;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    }
} <span class="org-comment-delimiter">// </span><span class="org-comment">&#8592; 'speed' &#12399;&#12371;&#12371;&#12363;&#12425;&#28961;&#21177;&#12395;&#12394;&#12427;</span>
</pre>
</div>

<p>
このコードにおける変数 <code>speed</code> のライフタイムは <code>speedTest()</code> 関数を抜けるときです．ここで変数は100から109までの異なる値をとっています．
</p>

<p>
変数のライフタイムという観点では，以下のコードは先程の例とはかなり異なります：
</p>

<div class="org-src-container">
<pre class="src src-d"><span class="org-type">void</span> <span class="org-function-name">speedTest</span>() {
    <span class="org-keyword">foreach</span> (<span class="org-variable-name">i</span>; 0 .. 10) {
        <span class="org-type">int</span> <span class="org-variable-name">speed</span> = 100 + i; <span class="org-comment-delimiter">// </span><span class="org-comment">10&#20491;&#12398;&#21029;&#12293;&#12398;&#22793;&#25968;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    } <span class="org-comment-delimiter">// </span><span class="org-comment">&#8592; &#20491;&#12293;&#12398;&#22793;&#25968;&#12398;&#12521;&#12452;&#12501;&#12479;&#12452;&#12512;&#12399;&#12371;&#12371;&#12391;&#32066;&#12431;&#12427;</span>
}
</pre>
</div>
<p>
このコードでは10個の別々の変数が，それぞれ1つずつ値をとります．ループ中の各イテレーションでは，新しい変数がライフタイムを開始して，順に各イテレーション終了と共にライフタイムを終えます．
</p>
</div>
</div>

<div id="outline-container-org51d26fe" class="outline-3">
<h3 id="org51d26fe"><span class="section-number-3">1.2.</span> 仮引数のライフタイム</h3>
<div class="outline-text-3" id="text-1-2">
<p>
仮引数のライフタイムは，修飾子によって決まります．
</p>

<ul class="org-ul">
<li><code>ref</code>: 仮引数は単なる関数呼び出し時に指定された実引数へのエイリアスです． <code>ref</code> 仮引数は実引数のライフタイムに何の影響も及ぼしません．</li>
</ul>

<ul class="org-ul">
<li><code>in</code>: <i>値型</i> の仮引数は，関数に入ったときにライフタイムが始まり，抜けるときに終わります． <i>参照型</i> なら，ライフタイムは <code>ref</code> のときと同じです．</li>
</ul>

<ul class="org-ul">
<li><code>out</code>: <code>ref</code> と同じく仮引数は，関数呼び出し時に指定された実引数への単なるエイリアスです．唯一の違いとして，関数に入ったときに変数は <code>.init</code> 値に自動的にセットされます．</li>
</ul>

<ul class="org-ul">
<li><code>lazy</code>: 仮引数のライフタイムは，仮引数が実際に使われるときに始まり，その直後に終わります．</li>
</ul>

<p>
以下の例はここまでの4つの型を使った仮引数を使い，それらのライフタイムをコメントで説明しています．
</p>

<div class="org-src-container">
<pre class="src src-d"><span class="org-type">void</span> <span class="org-function-name">main</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">main_in</span>;      <span class="org-comment-delimiter">/* </span><span class="org-comment">main_in &#12398;&#20516;&#12399;&#20206;&#24341;&#25968;&#12395;&#12467;&#12500;&#12540;&#12373;&#12428;&#12414;&#12377;</span><span class="org-comment-delimiter"> */</span>

    <span class="org-type">int</span> <span class="org-variable-name">main_ref</span>;     <span class="org-comment-delimiter">/* </span><span class="org-comment">main_ref &#12399;&#33258;&#36523;&#12364;&#38306;&#25968;&#12395;&#28193;&#12373;&#12428;&#12414;&#12377;&#65294;</span><span class="org-comment-delimiter"> */</span>

    <span class="org-type">int</span> <span class="org-variable-name">main_out</span>;     <span class="org-comment-delimiter">/* </span><span class="org-comment">main_out &#12399;&#33258;&#36523;&#12364;&#38306;&#25968;&#12395;&#28193;&#12373;&#12428;&#12414;&#12377;&#65294;</span>
<span class="org-comment">                         int.init &#12398;&#20516;&#12364;&#38306;&#25968;&#12395;&#20837;&#12387;&#12383;&#12392;&#12365;&#12395;&#12475;&#12483;&#12488;&#12373;&#12428;&#12414;&#12377;</span><span class="org-comment-delimiter"> */</span>

    foo(main_in, main_ref, main_out, aCalculation());
}

<span class="org-type">void</span> <span class="org-function-name">foo</span>(
    <span class="org-keyword">in</span> <span class="org-type">int</span> <span class="org-variable-name">p_in</span>,       <span class="org-comment-delimiter">/* </span><span class="org-comment">p_in &#12398;&#12521;&#12452;&#12501;&#12479;&#12452;&#12512;&#12399;&#38306;&#25968;&#12395;&#20837;&#12427;&#12392;&#22987;&#12414;&#12426;</span>
<span class="org-comment">                        * &#38306;&#25968;&#12434;&#25244;&#12369;&#12427;&#12392;&#12365;&#12395;&#32066;&#12431;&#12426;&#12414;&#12377;&#65294;</span><span class="org-comment-delimiter"> */</span>

    <span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-variable-name">p_ref</span>,     <span class="org-comment-delimiter">/* </span><span class="org-comment">p_ref &#12399; main_ref &#12398;&#12456;&#12452;&#12522;&#12450;&#12473;&#12391;&#12377;.</span><span class="org-comment-delimiter"> */</span>

    <span class="org-keyword">out</span> <span class="org-type">int</span> <span class="org-variable-name">p_out</span>,     <span class="org-comment-delimiter">/* </span><span class="org-comment">p_out &#12399; of main_out &#12398;&#12456;&#12452;&#12522;&#12450;&#12473;&#12391;&#12377;&#65294;</span>
<span class="org-comment">                        * &#38306;&#25968;&#12395;&#20837;&#12427;&#38555;&#65292;&#20516;&#12364; int.init &#12395;&#12475;&#12483;&#12488;&#12373;&#12428;&#12414;&#12377;&#65294;</span><span class="org-comment-delimiter">*/</span>

    <span class="org-keyword">lazy</span> <span class="org-type">int</span> <span class="org-variable-name">p_lazy</span>) { <span class="org-comment-delimiter">/* </span><span class="org-comment">p_lazy &#12398;&#12521;&#12452;&#12501;&#12479;&#12452;&#12512;&#12399;&#21033;&#29992;&#12375;&#12383;&#26178;&#12395;&#22987;&#12414;&#12426;</span>
<span class="org-comment">                        * &#21033;&#29992;&#12375;&#12383;&#24460;&#12395;&#32066;&#12431;&#12426;&#12414;&#12377;&#65294;p_lazy &#12434;&#38306;&#25968;&#20869;&#12391;&#20351;&#12358;&#12392;&#12365;</span>
<span class="org-comment">                        * &#20516;&#12399; aCalculation() &#12434;&#27598;&#22238;&#21628;&#12435;&#12391;&#35336;&#31639;&#12373;&#12428;&#12414;&#12377;&#65294;</span><span class="org-comment-delimiter"> */</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
}

<span class="org-type">int</span> <span class="org-function-name">aCalculation</span>() {
    <span class="org-type">int</span> <span class="org-variable-name">result</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
    <span class="org-keyword">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf25d435" class="outline-3">
<h3 id="orgf25d435"><span class="section-number-3">1.3.</span> 基本操作</h3>
<div class="outline-text-3" id="text-1-3">
<p>
どんな型にも，変数のライフタイムを通じて3つの基本操作があります．
</p>

<ul class="org-ul">
<li>初期化: ライフタイムの開始</li>
<li>ファイナライズ: ライフタイムの終了</li>
<li>代入: 値の変更の総称</li>
</ul>

<p>
オブジェクトを想定すると，まず始めに初期化されるはずです．特定の型にはファイナライズがあるかもしれません．変数の値はライフタイムを通じて変化するかもしれません．
</p>
</div>

<div id="outline-container-org60926a0" class="outline-4">
<h4 id="org60926a0"><span class="section-number-4">1.3.1.</span> 初期化</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
全ての変数は利用前に初期化されるはずです．初期化は2つのステップがあります:
</p>

<ol class="org-ol">
<li>領域の確保: ここで領域とは変数の値をメモリ上に格納するための場所です．</li>
<li>構築: 領域上に初期値(または構造体やクラスのメンバの初期値)の設定．</li>
</ol>

<p>
全ての変数はメモリ上の場所を確保して生存しています．コンパイラーが生成するコードのうち幾つかは各変数に領域を確保するためのものです．
</p>

<p>
以下のような変数を考えてみましょう．
</p>

<div class="org-src-container">
<pre class="src src-d"><span class="org-type">int</span> <span class="org-variable-name">speed</span> = 123;
</pre>
</div>
<p>
これまで<a href="http://ddili.org/ders/d.en/value_vs_reference.html">値型と参照型の章</a>(訳注：未翻訳)で見てきたように，我々はこの変数がメモリ上のどこかで生存していることをイメージできます.
</p>

<pre class="example">
──┬─────┬─────┬─────┬──
  │     │ 123 │     │
──┴─────┴─────┴─────┴──
</pre>
<p>
変数が格納されるメモリ上の位置をアドレスと呼びます．つまり，変数はアドレス上で生存しています．変数の値が変更されたとき，新たな値が同じ場所に格納されます．
</p>

<div class="org-src-container">
<pre class="src src-d">++speed;
</pre>
</div>
<p>
新たな値は昔の値と同じ場所にいるはずです．
</p>

<pre class="example">
──┬─────┬─────┬─────┬──
  │     │ 124 │     │
──┴─────┴─────┴─────┴──
</pre>
<p>
構築は値を利用するために不可欠です．構築前の変数は使うことができないので，コンパイラは自動的に構築を実行します．
</p>

<p>
変数は3つの方法で構築できます:
</p>

<ol class="org-ol">
<li>デフォルト値: プログラマが値を明示的に指定しないとき</li>
<li>コピー: 同じ型の他の変数のコピーとして変数が構築されたとき</li>
<li>指定された値: プログラマが明示的に値を指定したとき</li>
</ol>

<p>
値が指定されないとき，変数の値はデフォルト値になります，つまり型の <code>.init</code> 値です．
</p>

<div class="org-src-container">
<pre class="src src-d"><span class="org-type">int</span> <span class="org-variable-name">speed</span>;
</pre>
</div>
<p>
この例の <code>speed</code> の値は <code>int.init</code> で， <code>0</code> になります．当然，変数はデフォルト値またはその他の値をライフタイム中にとります (<code>immutable</code> でない限り)．
</p>

<div class="org-src-container">
<pre class="src src-d"><span class="org-type">File</span> <span class="org-variable-name">file</span>;
</pre>
</div>
<p>
上の定義では，変数 <code>file</code> は <code>File</code> オブジェクトで，実際のファイルシステム上のファイルにはまだ紐付いていません．実際のファイルと紐付けるよう変更されるまで，使ってはいけません．
</p>

<p>
変数はときに，他の値をコピーすることで構築されます．
</p>

<div class="org-src-container">
<pre class="src src-d"><span class="org-type">int</span> <span class="org-variable-name">speed</span> = otherSpeed;
</pre>
</div>
<p>
上の <code>speed</code> は <code>otherSpeed</code> の値を使って構築されました．
</p>

<p>
後の章で見るように，この操作はクラス型の変数では異なる意味を持ちます．
</p>

<div class="org-src-container">
<pre class="src src-d"><span class="org-keyword">auto</span> <span class="org-variable-name">classVariable</span> = otherClassVariable;
</pre>
</div>
<p>
<code>classVariable</code> は <code>otherClassVariable</code> のコピーとして生存を開始したのですが，クラスには根本的に違う動作をします: <code>speed</code> と <code>otherSpeed</code> は別個の値ですが， <code>classValue</code> と <code>otherClassValue</code> は両方とも同じ値へのアクセスを提供します．これが値型と参照型の根本的な違いです．
</p>

<p>
最後に，変数は互換型(compatible type)の式によって構築できます．
</p>

<div class="org-src-container">
<pre class="src src-d"><span class="org-type">int</span> <span class="org-variable-name">speed</span> = someCalculation();
</pre>
</div>
<p>
上の <code>speed</code> は <code>someCalculation()</code> の返り値によって構築されます．
</p>
</div>
</div>

<div id="outline-container-org1ccb967" class="outline-4">
<h4 id="org1ccb967"><span class="section-number-4">1.3.2.</span> ファイナライズ</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
ファイナライズとは変数に為される終了処理，およびメモリを回収する処理です:
</p>

<ol class="org-ol">
<li>デストラクト: 変数に為されるべき，終了処理です．</li>
<li>変数のメモリ回収: 変数が生存していたメモリを回収します．</li>
</ol>

<p>
単純な基本型の場合，終了処理はありません．例えば， <code>int</code> 型変数の値は0に戻されたりはしません．このような変数は単にメモリを回収するだけで，他の変数で後ほど再利用されます．
</p>

<p>
一方で，特定の型はファイナライズ中に特殊な操作を必要とします．例えば， <code>File</code> オブジェクトは出力バッファにためられた文字をディスクに書き込み，ファイルシステムに利用終了を通知する必要があります．これらの処理が <code>File</code> オブジェクトのデストラクトです．
</p>

<p>
配列の終了処理は，やや高レベルです: 配列のファイナライズ前に，まず各要素がデストラクトされます．もし要素が <code>int</code> のような単純な基本型の場合，特定の終了処理はありません．もし要素型が構造体やクラスのときは，ファイナライズが必要なので，各要素に対して実行されます．
</p>

<p>
連想配列も配列と同様です．追加で，キー型がファイナライズを必要とするとき，キーもファイナライズされます．
</p>

<p>
<b>ガベージコレクタ</b>: D言語はガベージコレクタのある言語です．このような言語ではオブジェクトのファイナライズはプログラマによって明示的に行う必要はありません．変数のライフタイムが終了した際，ファイナライズは自動的にガベージコレクタによって管理されます．我々はガベージコレクタと特殊なメモリ管理について<a href="http://ddili.org/ders/d.en/memory.html">後の章</a>でカバーします．
</p>

<p>
変数には次の2種類のファイナライズがあります．
</p>

<ol class="org-ol">
<li>ライフタイムを終えるとき: ファイナライズは変数の生存が終了するとき発生します．</li>
<li>将来のいつか：ファイナライズは未来の決定不能な時刻にガベージコレクタによって発生します．</li>
</ol>

<p>
この2種類のどちらによってファイナライズされるかは，変数の型によります．配列，連想配列，クラスは通常ガベージコレクタによって「将来のいつか」にデストラクトされます．
</p>
</div>
</div>

<div id="outline-container-org236476b" class="outline-4">
<h4 id="org236476b"><span class="section-number-4">1.3.3.</span> 代入</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
他の基本操作として，ライフタイム中の変数に対する代入があります．
</p>

<p>
単純な基本型における代入は変数の値を変更するだけです．先に見たメモリ表現のように， <code>int</code> 変数が 123 の代わり 124 という値を持つといった操作です．しかしながら，より一般的には，代入は2つのステップからなります，それらは必ずしも次の順序では行われません:
</p>

<ol class="org-ol">
<li>古い値のデストラクト</li>
<li>新しい値の構築</li>
</ol>

<p>
これらの2つのステップはデストラクトを必要としない単純な基本型においては重要ではありません．デストラクトが必要な型にとっては，代入がこれらの2ステップの組合せであることが重要なので覚えていてください．
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org7e6a1d6" class="outline-2">
<h2 id="org7e6a1d6"><span class="section-number-2">2.</span> 最近のライフタイム機能</h2>
<div class="outline-text-2" id="text-2">
<p>
前章では2017年ごろまでのD言語の基本的なライフタイムの考え方に関する解説を引用しました．ところで前章の触れなかったトピックとして，ライフタイムが終了した後の変数にアクセスする方法(未定義動作を引き起こします)と，それを防ぐ方法について，本章は解説します．
</p>
</div>

<div id="outline-container-orga570cee" class="outline-3">
<h3 id="orga570cee"><span class="section-number-3">2.1.</span> escaping reference</h3>
<div class="outline-text-3" id="text-2-1">
<p>
変数のライフタイムが終了するのは変数が定義したスコープを抜けるタイミングでした．例えば関数スコープのローカル変数を <code>ref</code> でうっかり返すだけで簡単にライフタイムが終了した変数にアクセスできそうです&#x2026;．
</p>
<div class="org-src-container">
<pre class="src src-d"><span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-function-name">fun</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">x</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">&#12371;&#12398; x &#12399; fun() &#12434;&#25244;&#12369;&#12427;&#12392;&#12521;&#12452;&#12501;&#12479;&#12452;&#12512;&#32066;&#20102;&#12375;&#12390;&#28961;&#21177;&#65294;&#32118;&#23550;&#12395;&#21442;&#29031;&#12434;&#36820;&#12375;&#12390;&#12399;&#12356;&#12369;&#12394;&#12356;&#65294;</span>
  <span class="org-keyword">return</span> x; <span class="org-comment-delimiter">// </span><span class="org-comment">Error: returning `x` escapes a reference to local variable `x`</span>
}
</pre>
</div>
<p>
しかし，最近のコンパイラは<a href="https://ja.wikipedia.org/wiki/%E3%82%A8%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%97%E8%A7%A3%E6%9E%90">エスケープ解析</a>が優秀なのでコンパイル時に検出してエラーにしてくれます(最近はC++(gcc)なども <code>-Wreturn-local-addr</code> でwarningを出してくれますね)．
</p>

<p>
<b>ところが，</b> コンパイラをだます方法はあります．参照を受け渡すだけの関数 <code>gun</code> を挟むことで，エスケープ解析を打ち切ってしまいます(C++も同様だと思います)．
</p>
<div class="org-src-container">
<pre class="src src-d"><span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-function-name">gun</span>(<span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-variable-name">y</span>) {
  <span class="org-keyword">return</span> y;
}

<span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-function-name">fun</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">x</span>;         <span class="org-comment-delimiter">// </span><span class="org-comment">&#12371;&#12398; x &#12399; fun() &#12434;&#25244;&#12369;&#12427;&#12392;&#12521;&#12452;&#12501;&#12479;&#12452;&#12512;&#32066;&#20102;&#12375;&#12390;&#28961;&#21177;</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">x &#12399; gun&#20869;&#37096;&#12391;&#12418;&#26377;&#21177;&#12384;&#12364;&#65292;&#12467;&#12531;&#12497;&#12452;&#12521;&#12399; gun &#12418; x &#12398;&#21442;&#29031;&#12434;&#36820;&#12377;&#12392;&#12399;&#35519;&#12409;&#12394;&#12356;</span>
  <span class="org-keyword">return</span> gun(x); <span class="org-comment-delimiter">// </span><span class="org-comment">Error: returning `x` escapes a reference to local variable `x`</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb84bbab" class="outline-3">
<h3 id="orgb84bbab"><span class="section-number-3">2.2.</span> return ref 仮引数</h3>
<div class="outline-text-3" id="text-2-2">
<p>
そこで<a href="https://wiki.dlang.org/DIP25">DIP25</a>で提案されたのが， <code>return ref</code> 属性です．
</p>

<p>
<a href="https://dlang.org/spec/function.html#return-ref-parameters">https://dlang.org/spec/function.html#return-ref-parameters</a>
</p>

<p>
規格にはチェックを有効にするには <code>-dip25</code> スイッチをコンパイラにつける必要があると書いてありますが， <b>このreturn ref自体は2.067からはデフォルトで有効になっています．</b> 後述する <code>@safe</code> との連携にはスイッチが必要です．
</p>

<p>
先程の例では次のように <code>return ref</code> と修飾するだけで参照した実引数が生存できるスコープを超える場合はエラーにできます．
</p>
<div class="org-src-container">
<pre class="src src-d"><span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-function-name">gun</span>(<span class="org-keyword">return</span> <span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-variable-name">y</span>) {
  <span class="org-keyword">return</span> y;
}

<span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-function-name">fun</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">x</span>;
  <span class="org-keyword">return</span> gun(x); <span class="org-comment-delimiter">// </span><span class="org-comment">Error: returning `gun(x)` escapes a reference to local variable `x`</span>
}
</pre>
</div>
<p>
この機能は単に，自分より外側にスコープを抜けないようにしているわけではなく，きちんと参照のライフタイムを追います．
</p>
<div class="org-src-container">
<pre class="src src-d"><span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-function-name">gun</span>(<span class="org-keyword">return</span> <span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-variable-name">y</span>) {
  <span class="org-keyword">return</span> y;
}

<span class="org-type">void</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">x</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">x &#12399; fun &#12398;&#22806;&#20596;&#12395;&#12356;&#12427;</span>
  <span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-function-name">fun</span>() {
    <span class="org-keyword">return</span> gun(x); <span class="org-comment-delimiter">// </span><span class="org-comment">OK</span>
  }
}
</pre>
</div>

<p>
なお， <code>inout ref</code> 仮引数や，テンプレート関数 <code>ref T foo(T)(ref T x)</code> の仮引数などは，暗黙のうちに <code>return ref</code> として推論されます．あと特別な例としてローカル関数も ref 仮引数に対してエスケープ解析が打ち切られることはないようです(規格には書いてない?)．
</p>

<p>
さらに，よくやってしまうメンバの参照返しで発生するライフタイム終了後の参照も <code>return</code> 属性でエラーにできます．これは <code>this</code> に対する <code>return</code> 修飾子(<code>auto foo() const</code> などと同じ)だと考えるとわかりやすいでしょう．
</p>
<div class="org-src-container">
<pre class="src src-d"><span class="org-keyword">struct</span> <span class="org-type">S</span> {
    <span class="org-keyword">private</span> <span class="org-type">int</span> <span class="org-variable-name">x</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#12371;&#12398; x &#12399; S &#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12398;&#12521;&#12452;&#12501;&#12479;&#12452;&#12512;&#20013;&#12398;&#12415;&#29983;&#23384;</span>
    <span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-function-name">get</span>() <span class="org-keyword">return</span> <span class="org-comment-delimiter">// </span><span class="org-comment">&#8592; &#12371;&#12371;</span>
    { <span class="org-keyword">return</span> <span class="org-variable-name">x</span>; }
}

<span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-function-name">escape</span>() {
    <span class="org-type">S</span> <span class="org-variable-name">s</span>;
    <span class="org-keyword">return</span> s.get(); <span class="org-comment-delimiter">// </span><span class="org-comment">Error: escaping reference to local variable s</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcee46fe" class="outline-3">
<h3 id="orgcee46fe"><span class="section-number-3">2.3.</span> <code>@safe</code> と <code>-dip25</code> を使う</h3>
<div class="outline-text-3" id="text-2-3">
<p>
注意点として，何処かで <code>return ref</code> 仮引数になっていれば安心というわけでは全くなくて，何処かで <code>return</code> 無しの <code>ref</code> 仮引数を使ってしまうとエスケープ解析が打ち切られてしまいます．そんな悲劇をさけるために， <code>@safe:</code> を全ソースコードに書き， <b><code>-dip25</code> スイッチをコンパイラに渡します．</b>
</p>
<div class="org-src-container">
<pre class="src src-d"><span class="org-comment-delimiter">// </span><span class="org-comment">$ dmd prog.d -ofprog.exe -dip25</span>
<span class="org-keyword">@safe</span>:
<span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-function-name">hun</span>(<span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> a; } <span class="org-comment-delimiter">// </span><span class="org-comment">Error: returning `a` escapes a reference to parameter `a`, perhaps annotate with `return`</span>
<span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-function-name">gun</span>(<span class="org-keyword">return</span> <span class="org-keyword">ref</span> <span class="org-type">int</span> <span class="org-variable-name">a</span>) { <span class="org-keyword">return</span> a; } <span class="org-comment-delimiter">// </span><span class="org-comment">FINE</span>
</pre>
</div>
<p>
<a href="https://wandbox.org/permlink/Oj6mwFqz3ZyNsRW3">https://wandbox.org/permlink/Oj6mwFqz3ZyNsRW3</a>
</p>

<p>
<code>return</code> のない <code>ref</code> 仮引数は使えなくなっていることがわかります．個人的には <code>@safe</code> がデフォルトであってほしいというか&#x2026;， <code>@unsafe</code> を作ってそれを明示してほしいですね．
</p>
</div>
</div>
</div>

<div id="outline-container-orgaf1449c" class="outline-2">
<h2 id="orgaf1449c"><span class="section-number-2">3.</span> DIP1000: Scoped Pointers</h2>
<div class="outline-text-2" id="text-3">
<p>
ここからはD言語の新機能DIP1000関連の話を解説します．Scoped Pointersとはざっくり言うと， <code>return ref</code> 仮引数のときは参照に限定されていたエスケープ解析をポインタやクラス全体に一般化した提案です．使い方はポインタ仮引数には <code>return score int* a</code> のように <code>return scope</code> として修飾して，ローカル変数のクラスやポインタには <code>scope int* i;</code> や <code>scope ClassType c;</code> として定義することで，ライフタイム終了後にアクセスされるとコンパイルエラーで禁止できます．
</p>

<p>
<a href="https://github.com/dlang/DIPs/blob/master/DIPs/DIP1000.md">https://github.com/dlang/DIPs/blob/master/DIPs/DIP1000.md</a>
</p>
</div>

<div id="outline-container-orgeb0e6e0" class="outline-3">
<h3 id="orgeb0e6e0"><span class="section-number-3">3.1.</span> 背景</h3>
<div class="outline-text-3" id="text-3-1">
<p>
DIP1000で引用されている過去の提案を見てみます．
</p>
</div>

<div id="outline-container-orge542101" class="outline-4">
<h4 id="orge542101"><span class="section-number-4">3.1.1.</span> DIP25: Sealed References (2.067で実装)</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
<a href="https://wiki.dlang.org/DIP25">https://wiki.dlang.org/DIP25</a>
前章で解説したやつです．
</p>
</div>
</div>

<div id="outline-container-org459cccb" class="outline-4">
<h4 id="org459cccb"><span class="section-number-4">3.1.2.</span> DIP35: Sealed References Amendment (ドラフト)</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
<a href="https://wiki.dlang.org/DIP35">https://wiki.dlang.org/DIP35</a>
ドラフトなのでとりあえず飛ばします．必要があれば後ほど解説．
</p>
</div>
</div>

<div id="outline-container-org9033037" class="outline-4">
<h4 id="org9033037"><span class="section-number-4">3.1.3.</span> DIP36: Rvalue References (否決)</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
<a href="https://wiki.dlang.org/DIP36">https://wiki.dlang.org/DIP36</a>
否決されたので詳細は飛ばします．ちなみに2018年は左辺値参照しか扱えなかった <code>ref T</code> で，右辺値参照もできるようにしようという提案があり，議論の最終段階にあります．
</p>

<p>
<a href="https://github.com/dlang/DIPs/blob/master/DIPs/DIP1016.md">https://github.com/dlang/DIPs/blob/master/DIPs/DIP1016.md</a>
</p>
</div>
</div>

<div id="outline-container-org2baea2a" class="outline-4">
<h4 id="org2baea2a"><span class="section-number-4">3.1.4.</span> DIP69: Implement scope for escape proof references (-&gt; DIP90 -&gt; DIP1000)</h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
この提案は一度消えてDIP1000として再提案されたようです．<a href="https://github.com/dlang/DIPs/blob/master/DIPs/DIP1000.md#abstract">"This is a reboot of DIP69."</a>
</p>

<p>
<b>TODO 2018/12/19: とりあえずDIP1000自体の解説に入る前に，今回はここで終わります．続きは正月に書きます．良いお年を．</b>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Shigeki Karita</p>
<p class="date">Created: 2021-10-12 Tue 15:32</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.2 (<a href="https://orgmode.org">Org</a> mode 9.4.4)</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
